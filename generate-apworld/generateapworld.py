"""
Utility to:
1) Load YAML from /tmp/chati.yaml into two dicts: items and locations
2) Write:
   - worlds/chatipelago/names/RegionName.py with variables mapping to lists
   - worlds/chatipelago/names/ItemName.py with ItemNum constants
3) Run build subprocess and move output to /tmp
"""

from __future__ import annotations

import os
import sys
import shutil
import subprocess
from pathlib import Path
from typing import Dict, List, Any

try:
    import yaml  # type: ignore
except Exception as exc:  # pragma: no cover
    raise RuntimeError(
        "PyYAML is required. Install with: pip install pyyaml"
    ) from exc


ROOT = Path(__file__).resolve().parent.parent  # repo root assumption: src/ is one level below
YAML_PATH = Path("/tmp/chati.yaml")
NAMES_DIR = ROOT / "worlds" / "chatipelago" / "names"
LAUNCHER_CMD = ["venv/bin/python", "Launcher.py", '"Build APWorlds"', "--", '"Chatipelago"']
BUILD_OUTPUT = ROOT / "builds" / "apworlds" / "chatipelago.apworld"
DEST_OUTPUT = Path("/tmp") / "chatipelago.apworld"


def load_yaml(path: Path) -> tuple[Dict[str, List[str]], Dict[str, List[str]]]:
    if not path.exists():
        raise FileNotFoundError(f"YAML file not found: {path}")
    with path.open("r", encoding="utf-8") as f:
        data: Dict[str, Any] = yaml.safe_load(f) or {}

    items = data.get("items")
    locations = data.get("locations")
    if not isinstance(items, dict) or not all(isinstance(v, list) for v in items.values()):
        # Nested categories under 'items': normal, trap, filler, prog
        raise ValueError("'items' must be a mapping of category -> list in YAML")
    if not isinstance(locations, dict) or not all(isinstance(v, list) for v in locations.values()):
        # Nested categories under 'locations': chatroom, prog
        raise ValueError("'locations' must be a mapping of category -> list in YAML")

    # Normalize lists to strings
    norm_items: Dict[str, List[str]] = {
        str(k): [str(x) for x in v] for k, v in items.items()
    }
    norm_locations: Dict[str, List[str]] = {
        str(k): [str(x) for x in v] for k, v in locations.items()
    }
    return norm_items, norm_locations


def write_region_names(locations: Dict[str, List[str]]) -> None:
    NAMES_DIR.mkdir(parents=True, exist_ok=True)
    region_file = NAMES_DIR / "RegionName.py"

    lines: List[str] = [
        "# Auto-generated by generateapworld.py",
    ]
    for category_name, location_list in locations.items():
        # Create a valid Python identifier (conservative replacement)
        var_name = "".join(ch if ch.isalnum() or ch == "_" else "_" for ch in str(category_name))
        if not var_name or var_name[0].isdigit():
            var_name = f"_{var_name}"
        rendered_list = ", ".join(repr(x) for x in location_list)
        lines.append(f"{var_name} = [{rendered_list}]")

    region_file.write_text("\n".join(lines) + "\n", encoding="utf-8", newline="\n")


def write_item_names(items: Dict[str, List[str]]) -> None:
    NAMES_DIR.mkdir(parents=True, exist_ok=True)
    item_file = NAMES_DIR / "ItemName.py"

    normal_list: List[str] = [str(x) for x in items.get("normal", [])]
    trap_list: List[str] = [str(x) for x in items.get("trap", [])]
    filler_list: List[str] = [str(x) for x in items.get("filler", [])]
    prog_list: List[str] = [str(x) for x in items.get("prog", [])]

    lines: List[str] = [
        "# Auto-generated by generateapworld.py",
    ]

    # Normal items numbered from 0 through 62
    for idx, name in enumerate(normal_list):
        lines.append(f"ItemNum{idx} = {name!r}")

    # Trap items starting at 197
    for offset, name in enumerate(trap_list):
        lines.append(f"ItemNum{197 + offset} = {name!r}")

    # Filler items starting at 200
    for offset, name in enumerate(filler_list):
        lines.append(f"ItemNum{200 + offset} = {name!r}")

    # Progression items starting at 300
    for offset, name in enumerate(prog_list):
        lines.append(f"ItemNum{300 + offset} = {name!r}")

    item_file.write_text("\n".join(lines) + "\n", encoding="utf-8", newline="\n")


def run_build_subprocess() -> int:
    # Execute from repo root to match expected paths
    proc = subprocess.run(LAUNCHER_CMD, cwd=ROOT)
    return proc.returncode


def move_output() -> None:
    if not BUILD_OUTPUT.exists():
        raise FileNotFoundError(f"Build output not found: {BUILD_OUTPUT}")
    DEST_OUTPUT.parent.mkdir(parents=True, exist_ok=True)
    # Replace existing file atomically if present
    if DEST_OUTPUT.exists():
        DEST_OUTPUT.unlink()
    shutil.move(str(BUILD_OUTPUT), str(DEST_OUTPUT))


def main() -> int:
    items, locations = load_yaml(YAML_PATH)
    write_region_names(locations)
    write_item_names(items)

    code = run_build_subprocess()
    if code != 0:
        print(f"Build process failed with exit code {code}", file=sys.stderr)
        return code

    move_output()
    print(f"Wrote: {DEST_OUTPUT}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())