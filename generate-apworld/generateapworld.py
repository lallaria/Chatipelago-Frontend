"""
Utility to:
1) Load YAML from /tmp/chati.yaml into two dicts: items and locations
2) Write:
   - worlds/chatipelago/names/RegionName.py with variables mapping to lists
   - worlds/chatipelago/names/ItemName.py with ItemNum constants
3) Run build subprocess and move output to /tmp
"""

from __future__ import annotations

import os
import sys
import shutil
import subprocess
import logging
from pathlib import Path
from typing import Dict, List, Any

try:
    import yaml  # type: ignore
except Exception as exc:  # pragma: no cover
    raise RuntimeError(
        "PyYAML is required. Install with: pip install pyyaml"
    ) from exc


ROOT = Path(__file__).resolve().parent.parent  # repo root assumption: src/ is one level below
YAML_PATH = Path("/tmp/chati.yaml")
NAMES_DIR = ROOT / "worlds" / "chatipelago" / "names"
LAUNCHER_CMD = ["venv/bin/python", "Launcher.py", '"Build APWorlds"', "--", '"Chatipelago"']
BUILD_OUTPUT = ROOT / "builds" / "apworlds" / "chatipelago.apworld"
DEST_OUTPUT = Path("/tmp") / "chatipelago.apworld"

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
    filename="generate.log",
    filemode="a"
)
logger = logging.getLogger(__name__)


def load_yaml(path: Path) -> tuple[Dict[str, List[str]], Dict[str, List[str]]]:
    logger.info(f"Loading YAML from {path}")
    if not path.exists():
        logger.error(f"YAML file not found: {path}")
        raise FileNotFoundError(f"YAML file not found: {path}")
    with path.open("r", encoding="utf-8") as f:
        data: Dict[str, Any] = yaml.safe_load(f) or {}

    items = data.get("items")
    locations = data.get("locations")
    if not isinstance(items, dict) or not all(isinstance(v, list) for v in items.values()):
        # Nested categories under 'items': normal, trap, filler, prog
        logger.error("'items' must be a mapping of category -> list in YAML")
        raise ValueError("'items' must be a mapping of category -> list in YAML")
    if not isinstance(locations, dict) or not all(isinstance(v, list) for v in locations.values()):
        # Nested categories under 'locations': chatroom, prog
        logger.error("'locations' must be a mapping of category -> list in YAML")
        raise ValueError("'locations' must be a mapping of category -> list in YAML")

    # Normalize lists to strings
    norm_items: Dict[str, List[str]] = {
        str(k): [str(x) for x in v] for k, v in items.items()
    }
    norm_locations: Dict[str, List[str]] = {
        str(k): [str(x) for x in v] for k, v in locations.items()
    }
    logger.info(f"Loaded {len(norm_items)} item categories and {len(norm_locations)} location categories")
    return norm_items, norm_locations


def write_region_names(locations: Dict[str, List[str]]) -> None:
    logger.info(f"Writing region names to {NAMES_DIR / 'RegionName.py'}")
    NAMES_DIR.mkdir(parents=True, exist_ok=True)
    region_file = NAMES_DIR / "RegionName.py"

    lines: List[str] = [
        "# Auto-generated by generateapworld.py",
    ]
    for category_name, location_list in locations.items():
        # Create a valid Python identifier (conservative replacement)
        var_name = "".join(ch if ch.isalnum() or ch == "_" else "_" for ch in str(category_name))
        if not var_name or var_name[0].isdigit():
            var_name = f"_{var_name}"
        rendered_list = ", ".join(repr(x) for x in location_list)
        lines.append(f"{var_name} = [{rendered_list}]")
        logger.debug(f"Added region category '{category_name}' ({len(location_list)} locations) as '{var_name}'")

    region_file.write_text("\n".join(lines) + "\n", encoding="utf-8", newline="\n")
    logger.info(f"Wrote {len(locations)} region categories to {region_file}")


def write_item_names(items: Dict[str, List[str]]) -> None:
    logger.info(f"Writing item names to {NAMES_DIR / 'ItemName.py'}")
    NAMES_DIR.mkdir(parents=True, exist_ok=True)
    item_file = NAMES_DIR / "ItemName.py"

    normal_list: List[str] = [str(x) for x in items.get("normal", [])]
    trap_list: List[str] = [str(x) for x in items.get("trap", [])]
    filler_list: List[str] = [str(x) for x in items.get("filler", [])]
    prog_list: List[str] = [str(x) for x in items.get("prog", [])]

    logger.debug(f"Item counts: normal={len(normal_list)}, trap={len(trap_list)}, filler={len(filler_list)}, prog={len(prog_list)}")

    lines: List[str] = [
        "# Auto-generated by generateapworld.py",
    ]

    # Normal items numbered from 0 through 62
    for idx, name in enumerate(normal_list):
        lines.append(f"ItemNum{idx} = {name!r}")

    # Trap items starting at 197
    for offset, name in enumerate(trap_list):
        lines.append(f"ItemNum{197 + offset} = {name!r}")

    # Filler items starting at 200
    for offset, name in enumerate(filler_list):
        lines.append(f"ItemNum{200 + offset} = {name!r}")

    # Progression items starting at 300
    for offset, name in enumerate(prog_list):
        lines.append(f"ItemNum{300 + offset} = {name!r}")

    item_file.write_text("\n".join(lines) + "\n", encoding="utf-8", newline="\n")
    total_items = len(normal_list) + len(trap_list) + len(filler_list) + len(prog_list)
    logger.info(f"Wrote {total_items} item definitions to {item_file}")


def run_build_subprocess() -> int:
    # Execute from repo root to match expected paths
    logger.info(f"Running build subprocess: {' '.join(LAUNCHER_CMD)}")
    logger.debug(f"Working directory: {ROOT}")
    proc = subprocess.run(LAUNCHER_CMD, cwd=ROOT)
    if proc.returncode == 0:
        logger.info("Build subprocess completed successfully")
    else:
        logger.warning(f"Build subprocess exited with code {proc.returncode}")
    return proc.returncode


def move_output() -> None:
    logger.info(f"Moving build output from {BUILD_OUTPUT} to {DEST_OUTPUT}")
    if not BUILD_OUTPUT.exists():
        logger.error(f"Build output not found: {BUILD_OUTPUT}")
        raise FileNotFoundError(f"Build output not found: {BUILD_OUTPUT}")
    DEST_OUTPUT.parent.mkdir(parents=True, exist_ok=True)
    # Replace existing file atomically if present
    if DEST_OUTPUT.exists():
        logger.debug(f"Removing existing file at {DEST_OUTPUT}")
        DEST_OUTPUT.unlink()
    shutil.move(str(BUILD_OUTPUT), str(DEST_OUTPUT))
    logger.info(f"Successfully moved output to {DEST_OUTPUT}")


def main() -> int:
    logger.info("Starting APWorld generation process")
    try:
        items, locations = load_yaml(YAML_PATH)
        write_region_names(locations)
        write_item_names(items)

        code = run_build_subprocess()
        if code != 0:
            logger.error(f"Build process failed with exit code {code}")
            return code

        move_output()
        logger.info(f"APWorld generation completed successfully. Output: {DEST_OUTPUT}")
        return 0
    except Exception as e:
        logger.exception(f"Error during APWorld generation: {e}")
        raise


if __name__ == "__main__":
    raise SystemExit(main())